<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computing Velocities · VortexModel.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>VortexModel.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Getting Started Guide</a></li><li><a class="toctext" href="elements.html">Vortex Elements</a></li><li class="current"><a class="toctext" href="velocities.html">Computing Velocities</a><ul class="internal"><li><a class="toctext" href="#Sources-and-Targets-1">Sources and Targets</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="timemarching.html">Time Marching</a></li><li><a class="toctext" href="noflowthrough.html">Enforcing No-Flow-Through</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="velocities.html">Computing Velocities</a></li></ul><a class="edit-page" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/docs/src/velocities.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Computing Velocities</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Computing-Velocities-1" href="#Computing-Velocities-1">Computing Velocities</a></h1><h2><a class="nav-anchor" id="Sources-and-Targets-1" href="#Sources-and-Targets-1">Sources and Targets</a></h2><p>Velocity computations in vortex models essentially boils down to pairwise interactions between sources and targets. We may be interested in how a system of vortex elements induces velocity on at point, at multiple points, on other vortex elements, or on itself.</p><p>The three key functions for computing velocities are</p><ul><li><p><a href="velocities.html#VortexModel.Vortex.induce_velocity"><code>induce_velocity(target, source)</code></a></p></li><li><p><a href="velocities.html#VortexModel.Vortex.induce_velocity!"><code>induce_velocity!(velocity, target, source)</code></a></p></li><li><p><a href="velocities.html#VortexModel.Vortex.self_induce_velocity!"><code>self_induce_velocity!(velocity, source)</code></a></p></li></ul><p>The <a href="https://docs.julialang.org/en/latest/manual/style-guide.html#Append-!-to-names-of-functions-that-modify-their-arguments-1"><code>!</code> suffix</a> in the last two function signatures indicate that the <code>velocity</code> argument will be overwritten by the results of the computation.</p><p>Sources of velocity can be any one of:</p><ul><li><p>a single vortex element, e.g.</p><pre><code class="language-julia-repl">julia&gt; src = Vortex.Point(im, 1.0);

julia&gt; induce_velocity(0.0 + 0.0im, src)
0.15915494309189535 - 0.0im</code></pre></li><li><p>an array of homogenous vortex types, e.g.</p><pre><code class="language-julia-repl">julia&gt; srcs = Vortex.Point.([im, 1.0], 1.0);

julia&gt; induce_velocity(0.0 + 0.0im, srcs)
0.15915494309189535 - 0.15915494309189535im</code></pre></li><li><p>a tuple of different vortex types, e.g.</p><pre><code class="language-julia-repl">julia&gt; srcs₂ = Vortex.Point.([2im, 2.0], -2.0);

julia&gt; sys = (srcs, srcs₂);

julia&gt; induce_velocity(0.0 + 0.0im, sys)
0.0 + 0.0im</code></pre></li></ul><p>In the examples above, the target was just complex number <code>0.0 + 0.0im</code>. However we can also have</p><ul><li><p>an array of complex numbers, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets = Complex128.(1:3);

julia&gt; induce_velocity(targets, src)
3-element Array{Complex{Float64},1}:
 0.0795775+0.0795775im
  0.031831+0.063662im
 0.0159155+0.0477465im</code></pre></li><li><p>an array of vortex elements, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets₂ = Vortex.Point.(im*(1.0:3), 1.0);

julia&gt; induce_velocity(targets₂, src)
3-element Array{Complex{Float64},1}:
        0.0+0.0im
  -0.159155+0.0im
 -0.0795775+0.0im</code></pre></li><li><p>a tuple with any of the above, e.g.</p><pre><code class="language-julia-repl">julia&gt; targets₃ = Vortex.Point.(-3.0:-1, -1.0);

julia&gt; sys = (targets, (targets₂, targets₃));

julia&gt; induce_velocity(sys, src)
(Complex{Float64}[0.0795775+0.0795775im, 0.031831+0.063662im, 0.0159155+0.0477465im], (Complex{Float64}[0.0+0.0im, -0.159155+0.0im, -0.0795775+0.0im], Complex{Float64}[0.0159155-0.0477465im, 0.031831-0.063662im, 0.0795775-0.0795775im]))</code></pre></li></ul><p>Since the structure of these targets can get complicated, e.g. nested tuples), the library also provides a set of functions for creating and resizing the <code>velocity</code> variable for in-place computations. For example:</p><pre><code class="language-julia-repl">julia&gt; vels = allocate_velocity(sys)
(Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im], (Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im]))

julia&gt; induce_velocity!(vels, sys, src)
(Complex{Float64}[0.0795775+0.0795775im, 0.031831+0.063662im, 0.0159155+0.0477465im], (Complex{Float64}[0.0+0.0im, -0.159155+0.0im, -0.0795775+0.0im], Complex{Float64}[0.0159155-0.0477465im, 0.031831-0.063662im, 0.0795775-0.0795775im]))</code></pre><p>The remaining sections of this page list the documentation for all the relevant methods for computing velocities. More detailed examples that show these methods working together can be found in the <a href="quickstart.html#getting-started-1">getting started guide</a> and the <a href="https://github.com/darwindarak/VortexModel.jl/tree/master/examples">Jupyter notebooks</a>.</p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.allocate_velocity" href="#VortexModel.Vortex.allocate_velocity"><code>VortexModel.Vortex.allocate_velocity</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">allocate_velocity(srcs)</code></pre><p>Allocate arrays of <code>Complex128</code> to match the structure of <code>srcs</code></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.(rand(Complex128, 2), rand(2));

julia&gt; blobs  = Vortex.Blob.(rand(Complex128, 3), rand(3), rand(3));

julia&gt; allocate_velocity(points)
2-element Array{Complex{Float64},1}:
 0.0+0.0im
 0.0+0.0im

julia&gt; allocate_velocity((points, blobs))
(Complex{Float64}[0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L173-L193">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.reset_velocity!" href="#VortexModel.Vortex.reset_velocity!"><code>VortexModel.Vortex.reset_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reset_velocity!(vels[, srcs])</code></pre><p>Set all velocities in <code>vels</code> to zero</p><p>If <code>srcs</code> is provided, then the arrays in <code>vels</code> are resized their source counterpart, if necessary.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ẋs = (rand(Complex128, 1), rand(Complex128, 1))
(Complex{Float64}[0.236033+0.346517im], Complex{Float64}[0.312707+0.00790928im])

julia&gt; points = Vortex.Point.(rand(Complex128, 2), rand(2));

julia&gt; blobs  = Vortex.Blob.(rand(Complex128, 3), rand(3), rand(3));

julia&gt; reset_velocity!(ẋs, (points, blobs));

julia&gt; ẋs
(Complex{Float64}[0.0+0.0im, 0.0+0.0im], Complex{Float64}[0.0+0.0im, 0.0+0.0im, 0.0+0.0im])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L125-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.induce_velocity" href="#VortexModel.Vortex.induce_velocity"><code>VortexModel.Vortex.induce_velocity</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">induce_velocity(target, element)</code></pre><p>Compute the velocity induced by <code>element</code> on <code>target</code></p><p><code>target</code> can be:</p><ul><li><p>a <code>Complex128</code></p></li><li><p>a subtype of <code>Vortex.PointSource</code></p></li><li><p>an array or tuple of vortex elements</p></li></ul><p>while the <code>element</code> can be:</p><ul><li><p>any subtype of <code>Vortex.Element</code></p></li><li><p>an array or tuple of vortex elements</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; z = rand(Complex128)
0.23603334566204692 + 0.34651701419196046im

julia&gt; point = Vortex.Point(z, rand());

julia&gt; srcs = Vortex.Point.(rand(Complex128, 10), rand(10));

julia&gt; induce_velocity(z, srcs[1])
0.08722212007570912 + 0.14002850279102955im

julia&gt; induce_velocity(point, srcs[1])
0.08722212007570912 + 0.14002850279102955im

julia&gt; induce_velocity(z, srcs)
-0.4453372874427177 - 0.10592646656959151im

julia&gt; induce_velocity(point, srcs)
-0.4453372874427177 - 0.10592646656959151im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L195-L232">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.induce_velocity!" href="#VortexModel.Vortex.induce_velocity!"><code>VortexModel.Vortex.induce_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">induce_velocity!(vels, target, element)</code></pre><p>Compute the velocity induced by <code>element</code> on <code>target</code> and store the result in <code>vels</code></p><p><code>vels</code> should be the output of a call to <a href="velocities.html#VortexModel.Vortex.allocate_velocity"><code>allocate_velocity</code></a>, <code>target</code> can be an array or tuple of vortex elements, while the <code>element</code> can be:</p><ul><li><p>any subtype of <code>Vortex.Element</code></p></li><li><p>an array or tuple of vortex elements</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; cluster₁ = Vortex.Point.(rand(Complex128, 5), rand(5));

julia&gt; cluster₂ = Vortex.Point.(rand(Complex128, 5), rand(5));

julia&gt; targets = (cluster₁, cluster₂);

julia&gt; sources = Vortex.Blob.(rand(Complex128), rand(10), 0.1);

julia&gt; ẋs = allocate_velocity(targets);

julia&gt; induce_velocity!(ẋs, targets, sources);

julia&gt; ẋs
(Complex{Float64}[-1.28772-1.82158im, 1.9386-1.64147im, -1.56438+1.57158im, -0.626254+0.375842im, -0.806568-0.213201im], Complex{Float64}[-0.583672-2.26031im, -0.329778-1.43388im, 0.426927+1.55352im, -0.93755+0.241361im, -1.08949-0.35598im])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L234-L263">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.self_induce_velocity!" href="#VortexModel.Vortex.self_induce_velocity!"><code>VortexModel.Vortex.self_induce_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">self_induce_velocity!(vels, elements)</code></pre><p>Compute the self induced velocity of one or more vortex elements</p><p>This involves a recursive call to <code>self_induce_velocity!</code> and pairwise calls to <a href="velocities.html#VortexModel.Vortex.mutually_induce_velocity!"><code>mutually_induce_velocity!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.([-1, 1], 1.0)
2-element Array{VortexModel.Vortex.Points.Point,1}:
 Point Vortex: z = -1.0 + 0.0im, Γ = 1.0
 Point Vortex: z = 1.0 + 0.0im, Γ = 1.0

julia&gt; vels = allocate_velocity(points)
2-element Array{Complex{Float64},1}:
 0.0+0.0im
 0.0+0.0im

julia&gt; self_induce_velocity!(vels, points)

julia&gt; vels # should be ±0.25im/π
2-element Array{Complex{Float64},1}:
 0.0-0.0795775im
 0.0+0.0795775im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L283-L310">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.mutually_induce_velocity!" href="#VortexModel.Vortex.mutually_induce_velocity!"><code>VortexModel.Vortex.mutually_induce_velocity!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mutually_induce_velocity!(vs₁, vs₂, e₁, e₂)</code></pre><p>Compute the mutually induced velocities between <code>e₁</code> and <code>e₂</code> and store the results in <code>vs₁</code> and <code>vs₂</code></p><p>The default implementation simply calls <a href="velocities.html#VortexModel.Vortex.induce_velocity!"><code>induce_velocity!</code></a> twice. This method is meant to be overwritten to take advantage of symmetries in certain pairwise vortex interations. For example, the velocity kernel for a point vortex is antisymmetric, so in computing the mutually induced velocities of two arrays of point vortices, we can half the number of calls to the velocity kernel.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/d77e3e053975fd8553d3b569bb04c96d05c6142c/src/Vortex.jl#L265-L276">source</a><br/></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="velocities.html#VortexModel.Vortex.allocate_velocity"><code>VortexModel.Vortex.allocate_velocity</code></a></li><li><a href="velocities.html#VortexModel.Vortex.induce_velocity"><code>VortexModel.Vortex.induce_velocity</code></a></li><li><a href="velocities.html#VortexModel.Vortex.induce_velocity!"><code>VortexModel.Vortex.induce_velocity!</code></a></li><li><a href="velocities.html#VortexModel.Vortex.mutually_induce_velocity!"><code>VortexModel.Vortex.mutually_induce_velocity!</code></a></li><li><a href="velocities.html#VortexModel.Vortex.reset_velocity!"><code>VortexModel.Vortex.reset_velocity!</code></a></li><li><a href="velocities.html#VortexModel.Vortex.self_induce_velocity!"><code>VortexModel.Vortex.self_induce_velocity!</code></a></li></ul><footer><hr/><a class="previous" href="elements.html"><span class="direction">Previous</span><span class="title">Vortex Elements</span></a><a class="next" href="timemarching.html"><span class="direction">Next</span><span class="title">Time Marching</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vortex Elements · VortexModel.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>VortexModel.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Getting Started Guide</a></li><li class="current"><a class="toctext" href="elements.html">Vortex Elements</a><ul class="internal"><li><a class="toctext" href="#Built-in-Vortex-Types-1">Built-in Vortex Types</a></li><li><a class="toctext" href="#Vortex-Properties-1">Vortex Properties</a></li><li><a class="toctext" href="#Methods-on-Vortex-Sheets-1">Methods on Vortex Sheets</a></li><li><a class="toctext" href="#Methods-on-Plates-1">Methods on Plates</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="velocities.html">Computing Velocities</a></li><li><a class="toctext" href="timemarching.html">Time Marching</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="elements.html">Vortex Elements</a></li></ul><a class="edit-page" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/docs/src/elements.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Vortex-Elements-1" href="#Vortex-Elements-1">Vortex Elements</a></h1><p>The library currently has four built-in vortex types:</p><ul><li><p><a href="elements.html#VortexModel.Vortex.Points.Point"><code>Vortex.Point</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Blobs.Blob"><code>Vortex.Blob</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Sheets.Sheet"><code>Vortex.Sheet</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Plates.Plate"><code>Vortex.Plate</code></a> (at the moment, there can only be one plate in the fluid at at time)</p></li></ul><p>Most functions in the library that act on vortex elements can take either a single vortex element, or a collection of elements. These collections can be represented as an array or a tuple. Arrays should be used when the elements are the same type, for example:</p><pre><code class="language-jlcon">julia&gt; points = Vortex.Point.(rand(Complex128, 5), rand(5))
5-element Array{VortexModel.Vortex.Points.Point,1}:
 Point Vortex: z = 0.236 + 0.347im, Γ = 0.556
 Point Vortex: z = 0.313 + 0.008im, Γ = 0.437
 Point Vortex: z = 0.489 + 0.211im, Γ = 0.425
 Point Vortex: z = 0.952 + 1.0im, Γ = 0.773
 Point Vortex: z = 0.252 + 0.987im, Γ = 0.281

julia&gt; Vortex.impulse(points)
1.3362266530178137 - 1.2821936908564113im

julia&gt; blobs = [Vortex.Blob(rand(Complex128), rand(), 0.1) for i in 1:5]
5-element Array{VortexModel.Vortex.Blobs.Blob,1}:
 Vortex Blob: z = 0.209 + 0.251im, Γ = 0.02, δ = 0.1
 Vortex Blob: z = 0.288 + 0.86im, Γ = 0.077, δ = 0.1
 Vortex Blob: z = 0.64 + 0.874im, Γ = 0.279, δ = 0.1
 Vortex Blob: z = 0.751 + 0.645im, Γ = 0.078, δ = 0.1
 Vortex Blob: z = 0.848 + 0.086im, Γ = 0.553, δ = 0.1

julia&gt; Vortex.impulse(blobs)
0.41217890550975256 - 0.7325028967929701im</code></pre><p>Knowing that every element has the same type allows the compiler to perform more aggressive optimizations. Tuples are used when we want to mix and match <em>different</em> vortex types. For example:</p><pre><code class="language-julia">julia&gt; sys = (points, blobs);

julia&gt; Vortex.impulse(sys)
1.7484055585275664 - 2.0146965876493814im</code></pre><p>This rest of this page documents the data types that represent these elements and some key functions that act on them. For more detailed examples, please refer to the <a href="https://github.com/darwindarak/VortexModel.jl/tree/master/examples">Jupyter notebooks</a>.</p><h2><a class="nav-anchor" id="Built-in-Vortex-Types-1" href="#Built-in-Vortex-Types-1">Built-in Vortex Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Points.Point" href="#VortexModel.Vortex.Points.Point"><code>VortexModel.Vortex.Points.Point</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Point &lt;: Vortex.PointSource</code></pre><p>An immutable structure representing a point vortex</p><p><strong>Fields</strong></p><ul><li><p><code>z</code>: position</p></li><li><p><code>Γ</code>: circulation</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/Points.jl#L6-L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Blobs.Blob" href="#VortexModel.Vortex.Blobs.Blob"><code>VortexModel.Vortex.Blobs.Blob</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Blob &lt;: Vortex.PointSource</code></pre><p>An immutable structure representing a vortex blob</p><p><strong>Fields</strong></p><ul><li><p><code>z</code>: position</p></li><li><p><code>Γ</code>: circulation</p></li><li><p><code>δ</code>: blob radius</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/Blobs.jl#L7-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.Sheet" href="#VortexModel.Vortex.Sheets.Sheet"><code>VortexModel.Vortex.Sheets.Sheet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Sheet &lt;: Vortex.CompositeSource</code></pre><p>A vortex sheet represented by vortex blob control points</p><p><strong>Fields</strong></p><ul><li><p><code>blobs</code>: the underlying array of vortex blobs</p></li><li><p><code>Γs</code>: the cumulated sum of circulation starting from the first control point</p></li><li><p><code>δ</code>: the blob radius of all the vortex blobs</p></li></ul><p><strong>Constructors:</strong></p><ul><li><p><code>Sheet(zs, Γs, δ)</code> where <code>zs</code> is an array of positions for the control points</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/Sheets.jl#L7-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.Plate" href="#VortexModel.Vortex.Plates.Plate"><code>VortexModel.Vortex.Plates.Plate</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Plate &lt;: VortexCompositeSource</code></pre><p>An infinitely thin, flat plate, represented as a bound vortex sheet</p><p><strong>Fields</strong></p><ul><li><p><code>L</code></p><p>chord length</p></li><li><p><code>c</code></p><p>centroid</p></li><li><p><code>α</code></p><p>centroid velocity</p></li><li><p><code>Γ</code></p><p>total circulation</p></li><li><p><code>N</code></p><p>number of control points</p></li><li><p><code>ss</code></p><p>normalized positions (within [-1, 1]) of the control points</p></li><li><p><code>zs</code></p><p>control point coordinates</p></li><li><p><code>A</code></p><p>Chebyshev coefficients of the normal component of velocity induced along the plate by ambient vorticity</p></li><li><p><code>C</code></p><p>Chebyshev coefficients of the velocity induced along the plate by ambient vorticity</p></li><li><p><code>B₀</code></p><p>zeroth Chebyshev coefficient associated with body motion</p></li><li><p><code>B₁</code></p><p>first Chebyshev coefficient associated with body motion</p></li><li><p><code>dct!</code></p><p>Preplanned DCT used to perform the discrete Chebyshev transform</p></li></ul><p><strong>Constructors</strong></p><ul><li><p><code>Plate(N, L, c, α)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/Plates.jl#L11-L21">source</a><br/></section><h2><a class="nav-anchor" id="Vortex-Properties-1" href="#Vortex-Properties-1">Vortex Properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.position" href="#VortexModel.Vortex.position"><code>VortexModel.Vortex.position</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.position(src::PointSource)</code></pre><p>Returns the complex position of a <code>PointSource</code> type vortex element This is a required method for all subtypes of <code>PointSource</code>.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; point = Vortex.Point(1.0 + 0.0im, 1.0);

julia&gt; Vortex.position(point)
1.0 + 0.0im

julia&gt; points = Vortex.Point.([1.0im, 2.0im], 1.0);

julia&gt; Vortex.position.(points)
2-element Array{Complex{Float64},1}:
 0.0+1.0im
 0.0+2.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/Vortex.jl#L48-L69">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.circulation" href="#VortexModel.Vortex.circulation"><code>VortexModel.Vortex.circulation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.circulation(src)</code></pre><p>Returns the total circulation contained in <code>src</code> This is a required method for all vortex types.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; points = Vortex.Point.([1.0im, 2.0im], [1.0, 2.0]);

julia&gt; Vortex.circulation(points[1])
1.0

julia&gt; Vortex.circulation(points)
3.0

julia&gt; Vortex.circulation.(points)
2-element Array{Float64,1}:
 1.0
 2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/Vortex.jl#L72-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.impulse" href="#VortexModel.Vortex.impulse"><code>VortexModel.Vortex.impulse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.impulse(src)</code></pre><p>Return the aerodynamic impulse of <code>src</code> about (0,0):</p><div>\[P := \int \boldsymbol{x} \times \boldsymbol{\omega}\,\mathrm{d}A.\]</div><p>This is a required method for all vortex types.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; sys = (Vortex.Point(1.0im, π), Vortex.Blob(1.0im, -π, 0.1));

julia&gt; Vortex.impulse(sys[1])
3.141592653589793 + 0.0im

julia&gt; Vortex.impulse(sys)
0.0 + 0.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/Vortex.jl#L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.advect" href="#VortexModel.Vortex.advect"><code>VortexModel.Vortex.advect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">advect(src::PointSource, velocity::Complex128, Δt)</code></pre><p>Return a new vortex element that represents <code>src</code> advected by <code>velocity</code> over <code>Δt</code> If this method is implemented by any type <code>T &lt;: PointSource</code>, then an array of type <code>AbstractArray{T}</code> can be passed in the first two arguments of <a href="elements.html#VortexModel.Vortex.advect!"><code>advect!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; point = Vortex.Point(1.0 + 0.0, 1.0);

julia&gt; advect(point, 1.0im, 1e-2)
Point Vortex: z = 1.0 + 0.01im, Γ = 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/Vortex.jl#L284-L299">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.advect!" href="#VortexModel.Vortex.advect!"><code>VortexModel.Vortex.advect!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">advect!(srcs₊, srcs₋, vels, Δt)</code></pre><p>Moves the elements in <code>srcs₋</code> by their corresponding velocity in <code>vels</code> over the interval <code>Δt</code> and store the results in <code>src₊</code> <code>srcs₋</code> and <code>srcs₊</code> can be either a array of vortex elements or a tuple.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; points₋ = [Vortex.Point(x + 0im, 1.0) for x in 1:5];

julia&gt; points₊ = Vector{Vortex.Point}(5);

julia&gt; vels = [ y*im for y in 1.0:5 ];

julia&gt; advect!(points₊, points₋, vels, 1e-2)

julia&gt; points₊
5-element Array{VortexModel.Vortex.Points.Point,1}:
 Point Vortex: z = 1.0 + 0.01im, Γ = 1.0
 Point Vortex: z = 2.0 + 0.02im, Γ = 1.0
 Point Vortex: z = 3.0 + 0.03im, Γ = 1.0
 Point Vortex: z = 4.0 + 0.04im, Γ = 1.0
 Point Vortex: z = 5.0 + 0.05im, Γ = 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/Vortex.jl#L309-L334">source</a><br/></section><h2><a class="nav-anchor" id="Methods-on-Vortex-Sheets-1" href="#Methods-on-Vortex-Sheets-1">Methods on Vortex Sheets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.truncate!" href="#VortexModel.Vortex.Sheets.truncate!"><code>VortexModel.Vortex.Sheets.truncate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.truncate!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return the circulation in those segments.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Vortex.Sheets.truncate!(sheet, 5)
4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/sheets/surgery.jl#L34-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.remesh!" href="#VortexModel.Vortex.Sheets.remesh!"><code>VortexModel.Vortex.Sheets.remesh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.remesh!(sheet, zs, Γs)</code></pre><p>Redistribute the control points of the sheet to lie on <code>zs</code> with circulation <code>Γs</code>.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Vortex.Sheets.remesh!(sheet, 0:0.2:2, 2sheet.Γs)
Vortex Sheet: L ≈ 2.0, Γ = 20.0, δ = 0.2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/sheets/surgery.jl#L58-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.split!" href="#VortexModel.Vortex.Sheets.split!"><code>VortexModel.Vortex.Sheets.split!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.split!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return those segments as a new sheet.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sheet₋ = Vortex.Sheets.split!(sheet, 5)
Vortex Sheet: L ≈ 0.4, Γ = 4.0, δ = 0.2

julia&gt; sheet
Vortex Sheet: L ≈ 0.6, Γ = 6.0, δ = 0.2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/sheets/surgery.jl#L3-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.filter!" href="#VortexModel.Vortex.Sheets.filter!"><code>VortexModel.Vortex.Sheets.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.filter!(sheet, Δs, Δf)</code></pre><p>Apply Fourier filtering to the sheet position and strengths.  The control points are redistributed to maintain a nominal point spacing of of <code>Δs</code>, and the filtering removes any length scales smaller than <code>Δf</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/sheets/surgery.jl#L102-L109">source</a><br/></section><h2><a class="nav-anchor" id="Methods-on-Plates-1" href="#Methods-on-Plates-1">Methods on Plates</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.enforce_no_flow_through!" href="#VortexModel.Vortex.Plates.enforce_no_flow_through!"><code>VortexModel.Vortex.Plates.enforce_no_flow_through!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">enforce_no_flow_through!(p::Plate, motion, elements)</code></pre><p>Update the plate, <code>p</code>, to enforce the no-flow-through condition given ambient vortex elements, <code>elements</code>, and while moving with kinematics specified by <code>motion</code>.</p><p><strong>Example</strong></p><pre><code class="language-jlcon">julia&gt; plate = Vortex.Plate(128, 2.0, 0.0, π/3)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = allocate_velocity(plate); motion.ċ = 1.0;

julia&gt; point = Vortex.Point(0.0 + 2im, 1.0);

julia&gt; Vortex.enforce_no_flow_through!(plate, motion, point)

julia&gt; plate
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 1.27, TESP = -1.93</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/plates/boundary_conditions.jl#L1-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.vorticity_flux" href="#VortexModel.Vortex.Plates.vorticity_flux"><code>VortexModel.Vortex.Plates.vorticity_flux</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vorticity_flux(p::Plate, v₁, v₂,
               lesp = 0.0, tesp = 0.0,
               ∂C₁ = Vector{Complex128}(plate.N),
               ∂C₂ = Vector{Complex128}(plate.N))</code></pre><p>Return strengths of new vortex elements that satisfies edge suction parameters. For a given edge, if the current suction parameter is less than the criticial suction parameter, then no vorticity is released.  If it is higher, however, vorticity will be released so that the suction parameter equals the critical value.</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: the plate</p></li><li><p><code>v₁, v₂</code>: the vortex elements (with unit circulation) that the vorticity flux is going into</p></li><li><p><code>lesp</code>, <code>tesp</code>: the critical leading and trailing edge suction parameters we want to enforce.  By default, both parameters are set to 0.0 to enforce the Kutta condition on both edges.  We can disable vortex shedding from an edge by setting the its critical suction parameter to <code>Inf</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Γ₁, Γ₂</code>: the strengths that the vortex element should have in order to satisfy the edge suction parameters</p></li><li><p><code>∂C₁, ∂C₂</code>: Chebyshev coefficients of the normal velocity induced by the vortex elements Instead of running <code>enforce_bc!</code> with the new vortex elements, we can use this matrix to directly update the Chebyshev coefficients associated with the bound vortex sheet without recomputing all the velocities.</p></li></ul><p><strong>Example</strong></p><p>Enforcing the trailing edge Kutta condition with an point vortex at negative infinity:</p><pre><code class="language-jlcon">julia&gt; plate = Vortex.Plate(128, 2.0, 0.0, π/6)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 30.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = allocate_velocity(plate);

julia&gt; motion.ċ = 1.0;

julia&gt; Vortex.enforce_no_flow_through!(plate, motion, ())

julia&gt; point = Vortex.Point(-Inf, 1.0);

julia&gt; _, Γ, _, _ = Vortex.vorticity_flux(plate, (), point,  Inf);

julia&gt; Γ # should equal -πULsin(α) = -π
-3.1415926535897927</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/plates/boundary_conditions.jl#L63-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.vorticity_flux!" href="#VortexModel.Vortex.Plates.vorticity_flux!"><code>VortexModel.Vortex.Plates.vorticity_flux!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vorticity_flux!(p::Plate, v₁, v₂,
                lesp = 0.0, tesp = 0.0,
                ∂C₁ = Vector{Complex128}(plate.N),
                ∂C₂ = Vector{Complex128}(plate.N))</code></pre><p>In-place version of <a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux"><code>vorticity_flux</code></a>, except instead of just returning the possible changes in plate Chebyshev coefficients, we modify <code>plate.C</code> with those changes so that no-flow-through is enforced in the presence of <code>v₁</code> and <code>v₂</code> with strengths that satisfy the suction parameters.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/bce210c10fda23644693a5bdf38d351d52ebc1fe/src/elements/plates/boundary_conditions.jl#L148-L159">source</a><br/></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="elements.html#VortexModel.Vortex.Blobs.Blob"><code>VortexModel.Vortex.Blobs.Blob</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.Plate"><code>VortexModel.Vortex.Plates.Plate</code></a></li><li><a href="elements.html#VortexModel.Vortex.Points.Point"><code>VortexModel.Vortex.Points.Point</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.Sheet"><code>VortexModel.Vortex.Sheets.Sheet</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.enforce_no_flow_through!"><code>VortexModel.Vortex.Plates.enforce_no_flow_through!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux"><code>VortexModel.Vortex.Plates.vorticity_flux</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux!"><code>VortexModel.Vortex.Plates.vorticity_flux!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.filter!"><code>VortexModel.Vortex.Sheets.filter!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.remesh!"><code>VortexModel.Vortex.Sheets.remesh!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.split!"><code>VortexModel.Vortex.Sheets.split!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.truncate!"><code>VortexModel.Vortex.Sheets.truncate!</code></a></li><li><a href="elements.html#VortexModel.Vortex.advect"><code>VortexModel.Vortex.advect</code></a></li><li><a href="elements.html#VortexModel.Vortex.advect!"><code>VortexModel.Vortex.advect!</code></a></li><li><a href="elements.html#VortexModel.Vortex.circulation"><code>VortexModel.Vortex.circulation</code></a></li><li><a href="elements.html#VortexModel.Vortex.impulse"><code>VortexModel.Vortex.impulse</code></a></li><li><a href="elements.html#VortexModel.Vortex.position"><code>VortexModel.Vortex.position</code></a></li></ul><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Getting Started Guide</span></a><a class="next" href="velocities.html"><span class="direction">Next</span><span class="title">Computing Velocities</span></a></footer></article></body></html>

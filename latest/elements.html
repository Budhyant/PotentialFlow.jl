<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vortex Elements · VortexModel.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>VortexModel.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Getting Started Guide</a></li><li class="current"><a class="toctext" href="elements.html">Vortex Elements</a><ul class="internal"><li><a class="toctext" href="#Built-in-Vortex-Types-1">Built-in Vortex Types</a></li><li><a class="toctext" href="#Vortex-Properties-1">Vortex Properties</a></li><li><a class="toctext" href="#Methods-on-Vortex-Sheets-1">Methods on Vortex Sheets</a></li><li><a class="toctext" href="#Methods-on-Plates-1">Methods on Plates</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li><li><a class="toctext" href="velocities.html">Computing Velocities</a></li><li><a class="toctext" href="timemarching.html">Time Marching</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="elements.html">Vortex Elements</a></li></ul><a class="edit-page" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/docs/src/elements.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Vortex-Elements-1" href="#Vortex-Elements-1">Vortex Elements</a></h1><p>The library currently has four built-in vortex types:</p><ul><li><p><a href="elements.html#VortexModel.Vortex.Points.Point"><code>Vortex.Point</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Blobs.Blob"><code>Vortex.Blob</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Sheets.Sheet"><code>Vortex.Sheet</code></a></p></li><li><p><a href="elements.html#VortexModel.Vortex.Plates.Plate"><code>Vortex.Plate</code></a> (at the moment, there can only be one plate in the fluid at at time)</p></li></ul><p>Most functions in the library that act on vortex elements can take either a single vortex element, or a collection of elements. These collections can be represented as an array or a tuple. Arrays should be used when the elements are the same type, for example:</p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.(rand(Complex128, 5), rand(5))
5-element Array{VortexModel.Vortex.Points.Point,1}:
 Point Vortex: z = 0.236 + 0.347im, Γ = 0.556
 Point Vortex: z = 0.313 + 0.008im, Γ = 0.437
 Point Vortex: z = 0.489 + 0.211im, Γ = 0.425
 Point Vortex: z = 0.952 + 1.0im, Γ = 0.773
 Point Vortex: z = 0.252 + 0.987im, Γ = 0.281

julia&gt; Vortex.impulse(points)
1.3362266530178137 - 1.2821936908564113im

julia&gt; blobs = [Vortex.Blob(rand(Complex128), rand(), 0.1) for i in 1:5]
5-element Array{VortexModel.Vortex.Blobs.Blob,1}:
 Vortex Blob: z = 0.209 + 0.251im, Γ = 0.02, δ = 0.1
 Vortex Blob: z = 0.288 + 0.86im, Γ = 0.077, δ = 0.1
 Vortex Blob: z = 0.64 + 0.874im, Γ = 0.279, δ = 0.1
 Vortex Blob: z = 0.751 + 0.645im, Γ = 0.078, δ = 0.1
 Vortex Blob: z = 0.848 + 0.086im, Γ = 0.553, δ = 0.1

julia&gt; Vortex.impulse(blobs)
0.41217890550975256 - 0.7325028967929701im</code></pre><p>Knowing that every element has the same type allows the compiler to perform more aggressive optimizations. Tuples are used when we want to mix and match <em>different</em> vortex types. For example:</p><pre><code class="language-julia">julia&gt; sys = (points, blobs);

julia&gt; Vortex.impulse(sys)
1.7484055585275664 - 2.0146965876493814im</code></pre><p>This rest of this page documents the data types that represent these elements and some key functions that act on them. For more detailed examples, please refer to the <a href="https://github.com/darwindarak/VortexModel.jl/tree/master/examples">Jupyter notebooks</a>.</p><h2><a class="nav-anchor" id="Built-in-Vortex-Types-1" href="#Built-in-Vortex-Types-1">Built-in Vortex Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Points.Point" href="#VortexModel.Vortex.Points.Point"><code>VortexModel.Vortex.Points.Point</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Point &lt;: Vortex.PointSource</code></pre><p>An immutable structure representing a point vortex</p><p><strong>Fields</strong></p><ul><li><p><code>z</code>: position</p></li><li><p><code>Γ</code>: circulation</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/Points.jl#L6-L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Blobs.Blob" href="#VortexModel.Vortex.Blobs.Blob"><code>VortexModel.Vortex.Blobs.Blob</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Blob &lt;: Vortex.PointSource</code></pre><p>An immutable structure representing a vortex blob</p><p><strong>Fields</strong></p><ul><li><p><code>z</code>: position</p></li><li><p><code>Γ</code>: circulation</p></li><li><p><code>δ</code>: blob radius</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/Blobs.jl#L7-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.Sheet" href="#VortexModel.Vortex.Sheets.Sheet"><code>VortexModel.Vortex.Sheets.Sheet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Sheet &lt;: Vortex.CompositeSource</code></pre><p>A vortex sheet represented by vortex blob control points</p><p><strong>Fields</strong></p><ul><li><p><code>blobs</code>: the underlying array of vortex blobs</p></li><li><p><code>Γs</code>: the cumulated sum of circulation starting from the first control point</p></li><li><p><code>δ</code>: the blob radius of all the vortex blobs</p></li><li><p><code>zs</code>: a mapped array that accesses the position of each control point</p></li></ul><p><strong>Constructors:</strong></p><ul><li><p><code>Sheet(blobs, Γs, δ)</code></p></li><li><p><code>Sheet(zs, Γs, δ)</code> where <code>zs</code> is an array of positions for the control points</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/Sheets.jl#L10-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.Plate" href="#VortexModel.Vortex.Plates.Plate"><code>VortexModel.Vortex.Plates.Plate</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Vortex.Plate &lt;: VortexCompositeSource</code></pre><p>An infinitely thin, flat plate, represented as a bound vortex sheet</p><p><strong>Fields</strong></p><ul><li><p><code>L</code></p><p>chord length</p></li><li><p><code>c</code></p><p>centroid</p></li><li><p><code>α</code></p><p>centroid velocity</p></li><li><p><code>Γ</code></p><p>total circulation</p></li><li><p><code>N</code></p><p>number of control points</p></li><li><p><code>ss</code></p><p>normalized positions (within [-1, 1]) of the control points</p></li><li><p><code>zs</code></p><p>control point coordinates</p></li><li><p><code>A</code></p><p>Chebyshev coefficients of the normal component of velocity induced along the plate by ambient vorticity</p></li><li><p><code>C</code></p><p>Chebyshev coefficients of the velocity induced along the plate by ambient vorticity</p></li><li><p><code>B₀</code></p><p>zeroth Chebyshev coefficient associated with body motion</p></li><li><p><code>B₁</code></p><p>first Chebyshev coefficient associated with body motion</p></li><li><p><code>dct!</code></p><p>Preplanned DCT used to perform the discrete Chebyshev transform</p></li></ul><p><strong>Constructors</strong></p><ul><li><p><code>Plate(N, L, c, α)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/Plates.jl#L11-L21">source</a><br/></section><h2><a class="nav-anchor" id="Vortex-Properties-1" href="#Vortex-Properties-1">Vortex Properties</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.position" href="#VortexModel.Vortex.position"><code>VortexModel.Vortex.position</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.position(src::PointSource)</code></pre><p>Returns the complex position of a <code>PointSource</code> type vortex element This is a required method for all subtypes of <code>PointSource</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; point = Vortex.Point(1.0 + 0.0im, 1.0);

julia&gt; Vortex.position(point)
1.0 + 0.0im

julia&gt; points = Vortex.Point.([1.0im, 2.0im], 1.0);

julia&gt; Vortex.position.(points)
2-element Array{Complex{Float64},1}:
 0.0+1.0im
 0.0+2.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/Vortex.jl#L51-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.circulation" href="#VortexModel.Vortex.circulation"><code>VortexModel.Vortex.circulation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.circulation(src)</code></pre><p>Returns the total circulation contained in <code>src</code> This is a required method for all vortex types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points = Vortex.Point.([1.0im, 2.0im], [1.0, 2.0]);

julia&gt; Vortex.circulation(points[1])
1.0

julia&gt; Vortex.circulation(points)
3.0

julia&gt; Vortex.circulation.(points)
2-element Array{Float64,1}:
 1.0
 2.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/Vortex.jl#L75-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.impulse" href="#VortexModel.Vortex.impulse"><code>VortexModel.Vortex.impulse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.impulse(src)</code></pre><p>Return the aerodynamic impulse of <code>src</code> about (0,0):</p><div>\[P := \int \boldsymbol{x} \times \boldsymbol{\omega}\,\mathrm{d}A.\]</div><p>This is a required method for all vortex types.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sys = (Vortex.Point(1.0im, π), Vortex.Blob(1.0im, -π, 0.1));

julia&gt; Vortex.impulse(sys[1])
3.141592653589793 + 0.0im

julia&gt; Vortex.impulse(sys)
0.0 + 0.0im</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/Vortex.jl#L100">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.advect" href="#VortexModel.Vortex.advect"><code>VortexModel.Vortex.advect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">advect(src::PointSource, velocity::Complex128, Δt)</code></pre><p>Return a new vortex element that represents <code>src</code> advected by <code>velocity</code> over <code>Δt</code> If this method is implemented by any type <code>T &lt;: PointSource</code>, then an array of type <code>AbstractArray{T}</code> can be passed in the first two arguments of <a href="elements.html#VortexModel.Vortex.advect!"><code>advect!</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; point = Vortex.Point(1.0 + 0.0, 1.0);

julia&gt; advect(point, 1.0im, 1e-2)
Point Vortex: z = 1.0 + 0.01im, Γ = 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/Vortex.jl#L342-L357">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.advect!" href="#VortexModel.Vortex.advect!"><code>VortexModel.Vortex.advect!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">advect!(srcs₊, srcs₋, vels, Δt)</code></pre><p>Moves the elements in <code>srcs₋</code> by their corresponding velocity in <code>vels</code> over the interval <code>Δt</code> and store the results in <code>src₊</code> <code>srcs₋</code> and <code>srcs₊</code> can be either a array of vortex elements or a tuple.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; points₋ = [Vortex.Point(x + 0im, 1.0) for x in 1:5];

julia&gt; points₊ = Vector{Vortex.Point}(5);

julia&gt; vels = [ y*im for y in 1.0:5 ];

julia&gt; advect!(points₊, points₋, vels, 1e-2)

julia&gt; points₊
5-element Array{VortexModel.Vortex.Points.Point,1}:
 Point Vortex: z = 1.0 + 0.01im, Γ = 1.0
 Point Vortex: z = 2.0 + 0.02im, Γ = 1.0
 Point Vortex: z = 3.0 + 0.03im, Γ = 1.0
 Point Vortex: z = 4.0 + 0.04im, Γ = 1.0
 Point Vortex: z = 5.0 + 0.05im, Γ = 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/Vortex.jl#L367-L392">source</a><br/></section><h2><a class="nav-anchor" id="Methods-on-Vortex-Sheets-1" href="#Methods-on-Vortex-Sheets-1">Methods on Vortex Sheets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.append_segment!" href="#VortexModel.Vortex.Sheets.append_segment!"><code>VortexModel.Vortex.Sheets.append_segment!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.append_segment!(sheet::Sheet, z, Γ)</code></pre><p>Append a new segment with circulation <code>Γ</code> extending from the end of the sheet to <code>z</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sheet.blobs[end]
Vortex Blob: z = 1.0 + 0.0im, Γ = 0.5, δ = 0.2

julia&gt; Vortex.Sheets.append_segment!(sheet, 1.1, 2.0)

julia&gt; sheet
Vortex Sheet: L ≈ 1.1, Γ = 12.0, δ = 0.2

julia&gt; sheet.blobs[end]
Vortex Blob: z = 1.1 + 0.0im, Γ = 1.0, δ = 0.2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L259-L281">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.truncate!" href="#VortexModel.Vortex.Sheets.truncate!"><code>VortexModel.Vortex.Sheets.truncate!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.truncate!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return the circulation in those segments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Vortex.Sheets.truncate!(sheet, 5)
4.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L64-L78">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.redistribute_points!" href="#VortexModel.Vortex.Sheets.redistribute_points!"><code>VortexModel.Vortex.Sheets.redistribute_points!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.redistribute_points!(sheet, zs, Γs)</code></pre><p>Returns the modified sheet with replacement control points at positions <code>zs</code> and strength <code>Γs</code>.</p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sys = (sheet,)
(Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2,)

julia&gt; Vortex.Sheets.redistribute_points!(sheet, 0:0.2:2, 0.0:0.5:5)
Vortex Sheet: L ≈ 2.0, Γ = 5.0, δ = 0.2

julia&gt; sys[1]
Vortex Sheet: L ≈ 2.0, Γ = 5.0, δ = 0.2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L3-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.remesh" href="#VortexModel.Vortex.Sheets.remesh"><code>VortexModel.Vortex.Sheets.remesh</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.remesh(sheet, Δs::Float64 , params::Tuple = ())</code></pre><p>Uniformly redistribute the control points of the sheet to have a nominal spacing of <code>Δs</code>. Material quantities that should be redistributed along with the control points can be passed in as elements of <code>params</code>.</p><p>Returns the tuple <code>(z₌, Γ₌, L [, p₌])</code> where</p><ul><li><p><code>z₌</code> is an array with the positions of the uniformly distributed points</p></li><li><p><code>Γ₌</code> is circulation interpolated onto <code>z₌</code></p></li><li><p><code>L</code> is total length of the sheet</p></li><li><p><code>p₌</code> is a tuple containing the material quantities from <code>params</code> interpolated onto <code>z₌</code></p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; age = collect(10.0:-1:0);

julia&gt; Vortex.Sheets.remesh(sheet, 0.2, (age, ))
(Complex{Float64}[0.0+0.0im, 0.25+0.0im, 0.5+0.0im, 0.75+0.0im, 1.0+0.0im], [0.0, 2.5, 5.0, 7.5, 10.0], 1.0, ([10.0, 7.5, 5.0, 2.5, 0.0],))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L88-L112">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.remesh!" href="#VortexModel.Vortex.Sheets.remesh!"><code>VortexModel.Vortex.Sheets.remesh!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.remesh!(sheet::Sheet, Δs::Float64, params::Tuple = ())</code></pre><p>Same as <a href="elements.html#VortexModel.Vortex.Sheets.remesh"><code>Vortex.Sheets.remesh</code></a>, except <code>sheet</code> is replaced internally by a uniformly interpolated control points. Returns the tuple (sheet, L, p₌) where</p><ul><li><p><code>sheet</code> is the modified sheet</p></li><li><p><code>L</code> is total length of the sheet</p></li><li><p><code>p₌</code> is a tuple containing the material quantities from <code>params</code> interpolated onto the new control points of <code>sheet</code></p></li></ul><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; age = collect(10.0:-1:0);

julia&gt; Vortex.Sheets.remesh!(sheet, 0.2, (age,));

julia&gt; Vortex.position.(sheet.blobs)
5-element Array{Complex{Float64},1}:
  0.0+0.0im
 0.25+0.0im
  0.5+0.0im
 0.75+0.0im
  1.0+0.0im

julia&gt; age
5-element Array{Float64,1}:
 10.0
  7.5
  5.0
  2.5
  0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L146-L181">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.split!" href="#VortexModel.Vortex.Sheets.split!"><code>VortexModel.Vortex.Sheets.split!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.split!(sheet, n::Int)</code></pre><p>Remove segments <code>0:n</code> from <code>sheet</code>, and return those segments as a new sheet.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; sheet₋ = Vortex.Sheets.split!(sheet, 5)
Vortex Sheet: L ≈ 0.4, Γ = 4.0, δ = 0.2

julia&gt; sheet
Vortex Sheet: L ≈ 0.6, Γ = 6.0, δ = 0.2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L33-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.filter!" href="#VortexModel.Vortex.Sheets.filter!"><code>VortexModel.Vortex.Sheets.filter!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Vortex.Sheets.filter!(sheet, Δs, Δf[, params])</code></pre><p>Redistribute and filter the control points of a vortex sheet </p><p><strong>Arguments</strong></p><ul><li><p><code>sheet</code>: the vortex sheet to be modified</p></li><li><p><code>Δs</code>: the nominal spacing between the uniform points</p></li><li><p><code>Δf</code>: the minimum length scale that the filter should allow to pass through</p></li><li><p><code>params</code>: an optional tuple of vectors containing material properties</p></li></ul><p><strong>Returns</strong></p><p>If <code>params</code> is passed in, then its vectors will be overwritten by their interpolated values on the new control points, and the function returns the tuple (sheet, params). Otherwise, it returns (sheet, ())</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L290-L309">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.filter_position!" href="#VortexModel.Vortex.Sheets.filter_position!"><code>VortexModel.Vortex.Sheets.filter_position!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">filter_position!(s, Δf, L = arclength(z₌))</code></pre><p>Filter out any length scales in <code>s</code> that is smaller than <code>Δf</code>, storing the result back in <code>s</code>. <code>s</code> can be either a vector of complex positions, or a <code>Vortex.Sheet</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L327-L332">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.arclength" href="#VortexModel.Vortex.Sheets.arclength"><code>VortexModel.Vortex.Sheets.arclength</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arclength(s)</code></pre><p>Compute the polygonal arc length of <code>s</code>, where <code>s</code> can be either an vector of complex numbers or a <code>Vortex.Sheet</code>.</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2) Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2</p><p>julia&gt; Vortex.Sheets.arclength(sheet) 1.0</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L197-L211">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Sheets.arclengths" href="#VortexModel.Vortex.Sheets.arclengths"><code>VortexModel.Vortex.Sheets.arclengths</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arclengths(s)</code></pre><p>Cumulative sum of the polygonal arc length of <code>s</code>, where <code>s</code> can be either an vector of complex numbers or a <code>Vortex.Sheet</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; sheet = Vortex.Sheet(0:0.1:1, 0.0:10, 0.2)
Vortex Sheet: L ≈ 1.0, Γ = 10.0, δ = 0.2

julia&gt; Vortex.Sheets.arclengths(sheet)
11-element Array{Float64,1}:
 0.0
 0.1
 0.2
 0.3
 0.4
 0.5
 0.6
 0.7
 0.8
 0.9
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/sheets/surgery.jl#L221-L247">source</a><br/></section><h2><a class="nav-anchor" id="Methods-on-Plates-1" href="#Methods-on-Plates-1">Methods on Plates</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.enforce_no_flow_through!" href="#VortexModel.Vortex.Plates.enforce_no_flow_through!"><code>VortexModel.Vortex.Plates.enforce_no_flow_through!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">enforce_no_flow_through!(p::Plate, motion, elements)</code></pre><p>Update the plate, <code>p</code>, to enforce the no-flow-through condition given ambient vortex elements, <code>elements</code>, and while moving with kinematics specified by <code>motion</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; plate = Vortex.Plate(128, 2.0, 0.0, π/3)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = allocate_velocity(plate); motion.ċ = 1.0;

julia&gt; point = Vortex.Point(0.0 + 2im, 1.0);

julia&gt; Vortex.enforce_no_flow_through!(plate, motion, point)

julia&gt; plate
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 60.0ᵒ
       LESP = 1.27, TESP = -1.93</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/plates/boundary_conditions.jl#L1-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.vorticity_flux" href="#VortexModel.Vortex.Plates.vorticity_flux"><code>VortexModel.Vortex.Plates.vorticity_flux</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vorticity_flux(p::Plate, v₁, v₂,
               lesp = 0.0, tesp = 0.0,
               ∂C₁ = Vector{Complex128}(plate.N),
               ∂C₂ = Vector{Complex128}(plate.N))</code></pre><p>Return strengths of new vortex elements that satisfies edge suction parameters. For a given edge, if the current suction parameter is less than the criticial suction parameter, then no vorticity is released.  If it is higher, however, vorticity will be released so that the suction parameter equals the critical value.</p><p><strong>Arguments</strong></p><ul><li><p><code>p</code>: the plate</p></li><li><p><code>v₁, v₂</code>: the vortex elements (with unit circulation) that the vorticity flux is going into</p></li><li><p><code>lesp</code>, <code>tesp</code>: the critical leading and trailing edge suction parameters we want to enforce.  By default, both parameters are set to 0.0 to enforce the Kutta condition on both edges.  We can disable vortex shedding from an edge by setting the its critical suction parameter to <code>Inf</code></p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Γ₁, Γ₂</code>: the strengths that the vortex element should have in order to satisfy the edge suction parameters</p></li><li><p><code>∂C₁, ∂C₂</code>: Chebyshev coefficients of the normal velocity induced by the vortex elements Instead of running <code>enforce_bc!</code> with the new vortex elements, we can use this matrix to directly update the Chebyshev coefficients associated with the bound vortex sheet without recomputing all the velocities.</p></li></ul><p><strong>Example</strong></p><p>Enforcing the trailing edge Kutta condition with an point vortex at negative infinity:</p><pre><code class="language-julia-repl">julia&gt; plate = Vortex.Plate(128, 2.0, 0.0, π/6)
Plate: N = 128, L = 2.0, c = 0.0 + 0.0im, α = 30.0ᵒ
       LESP = 0.0, TESP = 0.0

julia&gt; motion = allocate_velocity(plate);

julia&gt; motion.ċ = 1.0;

julia&gt; Vortex.enforce_no_flow_through!(plate, motion, ())

julia&gt; point = Vortex.Point(-Inf, 1.0);

julia&gt; _, Γ, _, _ = Vortex.vorticity_flux(plate, (), point,  Inf);

julia&gt; Γ # should equal -πULsin(α) = -π
-3.1415926535897927</code></pre></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/plates/boundary_conditions.jl#L63-L106">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.vorticity_flux!" href="#VortexModel.Vortex.Plates.vorticity_flux!"><code>VortexModel.Vortex.Plates.vorticity_flux!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">vorticity_flux!(p::Plate, v₁, v₂,
                lesp = 0.0, tesp = 0.0,
                ∂C₁ = Vector{Complex128}(plate.N),
                ∂C₂ = Vector{Complex128}(plate.N))</code></pre><p>In-place version of <a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux"><code>vorticity_flux</code></a>, except instead of just returning the possible changes in plate Chebyshev coefficients, we modify <code>plate.C</code> with those changes so that no-flow-through is enforced in the presence of <code>v₁</code> and <code>v₂</code> with strengths that satisfy the suction parameters.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/plates/boundary_conditions.jl#L148-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.bound_circulation" href="#VortexModel.Vortex.Plates.bound_circulation"><code>VortexModel.Vortex.Plates.bound_circulation</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bound_circulation(plate[, s])</code></pre><p>Compute the bound circulation on the plate.</p><p><code>s</code> can be either a single normalized arc length coordinate (between -1 and 1), or a whole array of coordinates.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/plates/circulation.jl#L1-L8">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="VortexModel.Vortex.Plates.bound_circulation!" href="#VortexModel.Vortex.Plates.bound_circulation!"><code>VortexModel.Vortex.Plates.bound_circulation!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bound_circulation!(γs, plate[, ss])</code></pre><p>Compute the bound circulation of <code>plate</code> and store it in <code>γs</code>.</p><p>If an array, <code>ss</code>, with normalized arc length coordinates is omitted, then the circulation will be computed at the plate&#39;s Chebyshev nodes.</p></div><a class="source-link" target="_blank" href="https://github.com/darwindarak/VortexModel.jl/tree/fc40aca973f12eb5100fed984b562734abbe6d57/src/elements/plates/circulation.jl#L42-L49">source</a><br/></section><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="elements.html#VortexModel.Vortex.Blobs.Blob"><code>VortexModel.Vortex.Blobs.Blob</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.Plate"><code>VortexModel.Vortex.Plates.Plate</code></a></li><li><a href="elements.html#VortexModel.Vortex.Points.Point"><code>VortexModel.Vortex.Points.Point</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.Sheet"><code>VortexModel.Vortex.Sheets.Sheet</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.bound_circulation"><code>VortexModel.Vortex.Plates.bound_circulation</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.bound_circulation!"><code>VortexModel.Vortex.Plates.bound_circulation!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.enforce_no_flow_through!"><code>VortexModel.Vortex.Plates.enforce_no_flow_through!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux"><code>VortexModel.Vortex.Plates.vorticity_flux</code></a></li><li><a href="elements.html#VortexModel.Vortex.Plates.vorticity_flux!"><code>VortexModel.Vortex.Plates.vorticity_flux!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.append_segment!"><code>VortexModel.Vortex.Sheets.append_segment!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.arclength"><code>VortexModel.Vortex.Sheets.arclength</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.arclengths"><code>VortexModel.Vortex.Sheets.arclengths</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.filter!"><code>VortexModel.Vortex.Sheets.filter!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.filter_position!"><code>VortexModel.Vortex.Sheets.filter_position!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.redistribute_points!"><code>VortexModel.Vortex.Sheets.redistribute_points!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.remesh"><code>VortexModel.Vortex.Sheets.remesh</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.remesh!"><code>VortexModel.Vortex.Sheets.remesh!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.split!"><code>VortexModel.Vortex.Sheets.split!</code></a></li><li><a href="elements.html#VortexModel.Vortex.Sheets.truncate!"><code>VortexModel.Vortex.Sheets.truncate!</code></a></li><li><a href="elements.html#VortexModel.Vortex.advect"><code>VortexModel.Vortex.advect</code></a></li><li><a href="elements.html#VortexModel.Vortex.advect!"><code>VortexModel.Vortex.advect!</code></a></li><li><a href="elements.html#VortexModel.Vortex.circulation"><code>VortexModel.Vortex.circulation</code></a></li><li><a href="elements.html#VortexModel.Vortex.impulse"><code>VortexModel.Vortex.impulse</code></a></li><li><a href="elements.html#VortexModel.Vortex.position"><code>VortexModel.Vortex.position</code></a></li></ul><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Getting Started Guide</span></a><a class="next" href="velocities.html"><span class="direction">Next</span><span class="title">Computing Velocities</span></a></footer></article></body></html>
